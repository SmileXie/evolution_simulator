<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Evolotion Simulater</title>
<script src="decomp-0.2.0.js"></script>
<script src="matter.js"></script>
<style>
    #label {
        font-size: 24px;
    }
</style>
</head>
<body>
<div id="label"></div> 
<div id="canvas"></div>
<script>
// module aliases
var Engine = Matter.Engine,
    Render = Matter.Render,
    Runner = Matter.Runner,
    Bodies = Matter.Bodies,
    Body = Matter.Body,
    Composite = Matter.Composite;
    Common = Matter.Common;
    Events = Matter.Events;
    Bounds = Matter.Bounds;
    Vertices = Matter.Vertices;
    Vector = Matter.Vector;
    Collision = Matter.Collision;

var canvas_width = 1200;
var canvas_height = 600;

var engine = Engine.create();
var render = Render.create({
    element: document.getElementById('canvas'),
    engine: engine,
    options: {
        width: canvas_width,
        height: canvas_height,
        hasBounds: true,
        wireframes: false,
        background: '#0D7D98'
    }
});

var generation = 1;
var individualNumber = 1; // individual number in one batch

function sfc32(a, b, c, d) {
    return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        var t = (a + b) | 0;
        a = b ^ b >>> 9;
        b = c + (c << 3) | 0;
        c = (c << 21 | c >>> 11);
        d = d + 1 | 0;
        t = t + d | 0;
        c = c + t | 0;
        return (t >>> 0) / 4294967296;
    }
}

var individual_seed = 2456;
var environment_seed = 1123;

// seedable random number generator: https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
// Pad seed with Phi, Pi and E.
// https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number

var individualRand = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, individual_seed ^ 0xDEADBEEF);
var environmentRand = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, environment_seed ^ 0xDEADBEEF);

function getRandomInt(min, max, rand) {
    return Math.floor(rand() * (max - min + 1)) + min;
}

function getRandomFloat(min, max, rand) {
    return rand() * (max - min) + min;
}


var rockCategory = 1 << 0;
var individualNumOfBatch = 25; // number of individuals in one batch
var survivalToNextGeneration = 5; // start spawn new generation when this number of individuals survive

function polarToCartesian(angle, distance) {
    var radians = angle * Math.PI / 180;

    var x = distance * Math.cos(radians);
    var y = distance * Math.sin(radians);

    return { x: x, y: y };
}

function generateRamdonIndividual(num_in_generation) {
    const vertices_num = getRandomInt(4, 20, individualRand);
    let path = "";

    do {
        path = "";
        for (let i = 0; i < vertices_num; i++) {
            let angle = 360/vertices_num*i; // getRandomFloat(360/vertices_num*i, 360/vertices_num*(i+1), individualRand);
            let distance = getRandomFloat(40, 60, individualRand);
            let { x, y } = polarToCartesian(angle, distance);
            path += `${x} ${y} `;
        }
        let individual_vt = Vertices.fromPath(path);
        //let chamfer_radius = getRandomFloat(5, 20, environmentRand);
        //individual_vt = Vertices.chamfer(individual_vt, chamfer_radius);
        individual = Bodies.fromVertices(100, 0, individual_vt, {
            collisionFilter: {
                mask: rockCategory, 
                category: 1 << num_in_generation
            },
            restitution: getRandomFloat(0, 0.9, individualRand),
            friction: getRandomFloat(0.1, 1.0, individualRand),
            render: { 
                fillStyle: 'rgba(159, 23, 5, 0.7)',
                //strokeStyle: '#000000',
                //lineWidth: 1 
            }
        });
    } while (individual === undefined) // if the vertices can NOT be converted to a valid polygon, Bodies.fromVertices will return undefined

    return individual;
}

function generateGeneration() {
    let individuals = [];
    for (let i = 0; i < individualNumOfBatch; i++) {
        individuals.push(generateRamdonIndividual(i + 1));
    }
    return individuals;
}

var individuals = generateGeneration();

function generateRandomRocks(count) {
    const rocks = [];
    const x_interval = 100;
    const y_interval = 60;
    const allOnes32 = 0xffffffff;

    let slope_path = '0 0 400 400';
    let last_y = 400;
    for (let i = 0; i < count; i++) {
        let x = 400 + x_interval * (i + 1);
        let y;
        if (i % 10 == 1 || i % 10 == 2) {
            y = last_y;
        } else {
            y = getRandomFloat(
                400 + y_interval * i, 400 + y_interval * (i + 1), environmentRand);
        }
        slope_path += ` ${x} ${y}`;
        last_y = y;
    }

    slope_path += ` 0 ${y_interval * count}`;
    let slope_vt = Vertices.fromPath(slope_path);
    //slope_vt = Vertices.chamfer(slope_vt, 30);
    let slope = Bodies.fromVertices(0, 0, slope_vt, {
        isStatic: true, 
        render: { 
            fillStyle: '#F5AF05', 
            //strokeStyle: '#000000',
            //lineWidth: 2
        }
    });
    offset = Vector.sub(slope.position, slope.bounds.min);
    Body.setPosition(slope, offset);
    rocks.push(slope);

    let bottom_rock = Bodies.rectangle(400 + x_interval * (count + 2), 400 + y_interval * (count + 2), 2000, 30, { 
        isStatic: true, 
        collisionFilter: {
            category: rockCategory,
            mask: allOnes32
        },
        restitution: 0.1,
        friction: 1,
        render: { 
            fillStyle: '#F5AF05', 
            strokeStyle: '#000000',
            lineWidth: 2
        }
    });

    rocks.push(bottom_rock);

    return rocks;
}

const mountain = generateRandomRocks(50);
const mountainCom = Composite.create({bodies: mountain});
var individualCom = Composite.create({bodies: individuals});

var survivalCom = Composite.create();

// add all of the bodies to the world
Composite.add(engine.world, individualCom);
Composite.add(engine.world, mountainCom);
Composite.add(engine.world, survivalCom);

//engine.timing.timeScale = 5;

Render.run(render);

var runner = Runner.create();
Runner.run(runner, engine);

var individualStaticTime = 0;

document.getElementById("label").innerText = 
    `Generation ${generation}, Individual No. ${individualNumber} - ${individualNumber + individualNumOfBatch - 1}`;

function resetIndividuals() {
    // reset the view and generate a new individual batch
    Composite.clear(individualCom);
    individuals = generateGeneration();
    Composite.add(individualCom, individuals);

    Bounds.shift(render.bounds, {x:0, y:0});
}


function removeDeadIndividuals() {
    // remove individual that drops out of the rocks, 
    for (let i = 0; i < individuals.length; i++) {
        if (individuals[i].position.y > canvas_height * 10) {
            Composite.remove(mountainCom, individuals[i]);
            individuals.splice(i, 1);
            i--;
        }
    }
}

function findMaxXIndividual(individuals, removeMax = false) {
    if (individuals.length === 0) {
        return null;
    }

    let maxIndividual = individuals[0];
    for (let i = 1; i < individuals.length; i++) {
        if (individuals[i].position.x > maxIndividual.position.x) {
            maxIndividual = individuals[i]; 
        }
    }

    if (removeMax) {
        const index = individuals.indexOf(maxIndividual);
        if (index > -1) {
            individuals.splice(index, 1);
        }
    }

    return maxIndividual;
}


function findFastIndividual(individuals) {
    if (individuals.length === 0) {
        return null;
    }

    let fastIndividual = individuals[0];
    for (let i = 1; i < individuals.length; i++) {
        if (Body.getSpeed(individuals[i]) > Body.getSpeed(fastIndividual)) {
            fastIndividual = individuals[i]; 
        }
    }

    if (Body.getSpeed(fastIndividual) >= 0.5) {
        return fastIndividual;
    }
    
    fastIndividual = individuals[0];
    for (let i = 1; i < individuals.length; i++) {
        if (Body.getAngularSpeed(individuals[i]) > Body.getAngularSpeed(fastIndividual)) {
            fastIndividual = individuals[i]; 
        }
    }

    return fastIndividual;
}



function getSurvivalIndividuals(individuals) {
    
    const bottom_rock = mountain[mountain.length - 1];
    let survivals = [];
    let current_survive;
    do {
        let headmost = findMaxXIndividual(individuals, true);
        current_survive = false;
        if (Collision.collides(headmost, bottom_rock) != null) {
            Body.setStatic(headmost, true);
            survivals.push(headmost);
            current_survive = true;
        }
    } while (current_survive);
    
    return survivals;
}

function displaySurvivalIndividuals(survivals) {
    // position move along with the rednder.bounds
    const y = render.bounds.max.y - 80;
    for (let i = 0; i < survivals.length; i++) {
        const x = render.bounds.min.x + 80 + i * 160;
        Body.setPosition(survivals[i], {x: x, y: y});
    }
}

Events.on(render, 'beforeRender', function() {
    
    removeDeadIndividuals();

    const headmost = findMaxXIndividual(individuals);

    // move the camera to follow the individual
    if (headmost.position.x > canvas_width/2 && headmost.position.y <= canvas_height/2) {
        Bounds.shift(render.bounds, {x: headmost.position.x - canvas_width/2, y:0});
    }

    if (headmost.position.y > canvas_height/2 && headmost.position.x <= canvas_width/2) {
        Bounds.shift(render.bounds, {x: 0, y:headmost.position.y - canvas_height/2});
    }

    if (headmost.position.x > canvas_width/2 && headmost.position.y > canvas_height/2) {
        Bounds.shift(render.bounds, 
                        {x: headmost.position.x - canvas_width/2, y:headmost.position.y - canvas_height/2});
    }

    const fastIndividual = findFastIndividual(individuals);

    if (Body.getSpeed(fastIndividual) < 0.5 && Body.getAngularSpeed(fastIndividual) < 0.01) {
        individualStaticTime += 1;
    } else {
        individualStaticTime = 0;
    }

    // if all the individuals are static
    
    if (individualStaticTime > 300) {
        let batch_survivals = getSurvivalIndividuals(individuals);
        for (let i = 0; i < batch_survivals.length; i++) {
            Composite.remove(individualCom, batch_survivals[i]);
            Composite.add(survivalCom, batch_survivals[i]);
        }

        resetIndividuals();

        individualNumber += individualNumOfBatch;
        individualStaticTime = 0;
        console.log(`Individual No. ${individualNumber} - ${individualNumber + individualNumOfBatch - 1} generated`);
        document.getElementById(
            "label").innerText = `Generation ${generation}, Individual No. ${individualNumber} - ${individualNumber + individualNumOfBatch - 1}`;
    }
    displaySurvivalIndividuals(survivalCom.bodies);

});


</script>
</body>
</html>
