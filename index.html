<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Evolotion Simulater</title>
<script src="decomp-0.2.0.js"></script>
<script src="matter.js"></script>
<style>
    #label {
        font-size: 24px;
    }
</style>
</head>
<body>
<div id="label"></div> 
<div id="canvas"></div>
<script>
// module aliases
var Engine = Matter.Engine,
    Render = Matter.Render,
    Runner = Matter.Runner,
    Bodies = Matter.Bodies,
    Body = Matter.Body,
    Composite = Matter.Composite;
    Common = Matter.Common;
    Events = Matter.Events;
    Bounds = Matter.Bounds;
    Vertices = Matter.Vertices;

var canvas_width = 1200;
var canvas_height = 600;

var engine = Engine.create();
var render = Render.create({
    element: document.getElementById('canvas'),
    engine: engine,
    options: {
        width: canvas_width,
        height: canvas_height,
        hasBounds: true,
        wireframes: false,
        background: '#0D7D98'
    }
});

var generation = 1;
var individualNumber = 1; // individual number in one batch

function sfc32(a, b, c, d) {
    return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        var t = (a + b) | 0;
        a = b ^ b >>> 9;
        b = c + (c << 3) | 0;
        c = (c << 21 | c >>> 11);
        d = d + 1 | 0;
        t = t + d | 0;
        c = c + t | 0;
        return (t >>> 0) / 4294967296;
    }
}

var individual_seed = 1077;
var environment_seed = 1099;

// seedable random number generator: https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
// Pad seed with Phi, Pi and E.
// https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number

var individualRand = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, individual_seed ^ 0xDEADBEEF);
var environmentRand = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, environment_seed ^ 0xDEADBEEF);

function getRandomInt(min, max, rand) {
    return Math.floor(rand() * (max - min + 1)) + min;
}

function getRandomFloat(min, max, rand) {
    return rand() * (max - min) + min;
}


var rockCategory = 1 << 0;
var individualNumOfBatch = 25; // number of individuals in one batch

function generateRamdonIndividual(num_in_generation) {
    const vertices_num = getRandomInt(3, 50, individualRand);
    let vertices = [];

    do {
        vertices = [];
        for (let i = 0; i < vertices_num; i++) {
            const x = getRandomFloat(-50, 50, individualRand);
            const y = getRandomFloat(-50, 50, individualRand);
            vertices.push({x:x, y:y });
        }
        const chamfer_radius = getRandomFloat(0, 40, environmentRand);
        individual = Bodies.fromVertices(100, -200, vertices, {
            collisionFilter: {
                mask: rockCategory, 
                category: 1 << num_in_generation
            },
            chamfer: { radius: chamfer_radius },
            restitution: getRandomFloat(0, 1.0, individualRand),
            friction: getRandomFloat(0, 1.0, individualRand),
            render: { 
                fillStyle: 'rgba(159, 23, 5, 0.7)',
                strokeStyle: '#000000',
                lineWidth: 1 
            }
        });
    } while (individual === undefined) // if the vertices can NOT be converted to a valid polygon, Bodies.fromVertices will return undefined

    return individual;
}

function generateGeneration() {
    let individuals = [];
    for (let i = 0; i < individualNumOfBatch; i++) {
        individuals.push(generateRamdonIndividual(i + 1));
    }
    return individuals;
}

var individuals = generateGeneration();

function generateRandomRocks(count) {
    const rocks = [];
    const rocks_x_gap = canvas_width / 20;
    const rocks_y_gap = canvas_height / 20;
    const allOnes32 = 0xffffffff;

    let mountain_vt = Vertices.fromPath('0 0 100 100 200 80 300 150 400 200 0 200');
    mountain_vt = Vertices.chamfer(mountain_vt, 30)
    let mountain = Bodies.fromVertices(200, 400, mountain_vt, {
        isStatic: true, 
        render: { 
            fillStyle: '#F5AF05', 
            strokeStyle: '#000000',
            lineWidth: 2
        }
    }, true);

    rocks.push(mountain);
    
    for (let i = 0; i < count; i++) {
        const x = getRandomFloat(rocks_x_gap*i, rocks_x_gap*(i + 1), environmentRand);
        const y = getRandomFloat(100 + rocks_y_gap*i, 100 + rocks_y_gap*(i + 1), environmentRand);
        const radius = getRandomFloat(30, 100, environmentRand);
        const sides = getRandomInt(3, 10, environmentRand);
        const chamfer_radius = getRandomFloat(0, 30, environmentRand);
        let rock = Bodies.polygon(x, y, sides, radius, { 
            isStatic: true, 
            collisionFilter: {
                category: rockCategory,
                mask: allOnes32
            },
            chamfer: { radius: chamfer_radius },
            restitution: 0.1,
            friction: 1,
            render: { 
                fillStyle: '#F5AF05', 
                strokeStyle: '#000000',
                lineWidth: 2
            }
        });

        rocks.push(rock);
    }

    let bottom_rock = Bodies.rectangle(rocks_x_gap * count + 1000, rocks_y_gap * count + 150, 2000, 30, { 
        isStatic: true, 
        collisionFilter: {
            category: rockCategory,
            mask: allOnes32
        },
        restitution: 0.1,
        friction: 1,
        render: { 
            fillStyle: '#F5AF05', 
            strokeStyle: '#000000',
            lineWidth: 2
        }
    });

    rocks.push(bottom_rock);

    return rocks;
}

const mountain = generateRandomRocks(40);
const mountainCom = Composite.create({bodies: mountain});
var individualCom = Composite.create({bodies: individuals});
// add all of the bodies to the world
Composite.add(engine.world, individualCom);
Composite.add(engine.world, mountainCom);

//engine.timing.timeScale = 5;

Render.run(render);

var runner = Runner.create();
Runner.run(runner, engine);

var individualStaticTime = 0;


function resetIndividuals() {
    // reset the view and generate a new individual
    Composite.clear(individualCom);
    individuals = generateGeneration();
    Composite.add(individualCom, individuals);

    Bounds.shift(render.bounds, {x:0, y:0});
}


function removeDeadIndividuals() {
    // remove individual that drops out of the rocks, 
    for (let i = 0; i < individuals.length; i++) {
        if (individuals[i].position.y > canvas_height * 10) {
            Composite.remove(mountainCom, individuals[i]);
            individuals.splice(i, 1);
            i--;
        }
    }
}

function findMaxXIndividual(individuals) {
    if (individuals.length === 0) {
        return null;
    }

    let maxIndividual = individuals[0];
    for (let i = 1; i < individuals.length; i++) {
        if (individuals[i].position.x > maxIndividual.position.x) {
            maxIndividual = individuals[i]; 
        }
    }
    return maxIndividual;
}

function findFastIndividual(individuals) {
    if (individuals.length === 0) {
        return null;
    }

    let fastIndividual = individuals[0];
    for (let i = 1; i < individuals.length; i++) {
        if (Body.getSpeed(individuals[i]) > Body.getSpeed(fastIndividual)) {
            fastIndividual = individuals[i]; 
        }
    }

    if (Body.getSpeed(fastIndividual) >= 0.5) {
        return fastIndividual;
    }
    
    fastIndividual = individuals[0];
    for (let i = 1; i < individuals.length; i++) {
        if (Body.getAngularSpeed(individuals[i]) > Body.getAngularSpeed(fastIndividual)) {
            fastIndividual = individuals[i]; 
        }
    }

    return fastIndividual;
}

Events.on(render, 'beforeRender', function() {
    
    removeDeadIndividuals();

    const headmost = findMaxXIndividual(individuals);

    // move the camera to follow the individual
    if (headmost.position.x > canvas_width/2 && headmost.position.y <= canvas_height/2) {
        Bounds.shift(render.bounds, {x: headmost.position.x - canvas_width/2, y:0});
    }

    if (headmost.position.y > canvas_height/2 && headmost.position.x <= canvas_width/2) {
        Bounds.shift(render.bounds, {x: 0, y:headmost.position.y > canvas_height/2});
    }

    if (headmost.position.x > canvas_width/2 && headmost.position.y > canvas_height/2) {
        Bounds.shift(render.bounds, 
                        {x: headmost.position.x - canvas_width/2, y:headmost.position.y - canvas_height/2});
    }

    const fastIndividual = findFastIndividual(individuals);

    if (Body.getSpeed(fastIndividual) < 0.5 && Body.getAngularSpeed(fastIndividual) < 0.01) {
        individualStaticTime += 1;
    } else {
        individualStaticTime = 0;
    }

    // if all the individuals are static
    
    if (individualStaticTime > 300) {
        
        resetIndividuals();

        individualNumber += individualNumOfBatch;
        individualStaticTime = 0;
        console.log(`Individual No. ${individualNumber} - ${individualNumber + individualNumOfBatch - 1} generated`);
        document.getElementById(
            "label").innerText = `Generation ${generation}, Individual No. ${individualNumber} - ${individualNumber + individualNumOfBatch - 1}`;
    }

});

document.getElementById(
            "label").innerText = `Generation ${generation}, Individual No. ${individualNumber} - ${individualNumber + individualNumOfBatch - 1}`;



</script>
</body>
</html>
