<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Evolotion Simulater</title>
<script src="matter.js"></script>
</head>
<body>
<div id="c"></div>
<script>
// module aliases
var Engine = Matter.Engine,
    Render = Matter.Render,
    Runner = Matter.Runner,
    Bodies = Matter.Bodies,
    Composite = Matter.Composite;
    Common = Matter.Common;
    Events = Matter.Events;
    Bounds = Matter.Bounds;

var canvas_width = 1200;
var canvas_height = 600;

// create an engine
var engine = Engine.create();

// create a renderer
let render = Render.create({
    element: document.getElementById('c'),
    engine: engine,
    options: {
        width: canvas_width,
        height: canvas_height,
        hasBounds: true,
        wireframes: false,
        background: '#0D7D98'
    }
});

function sfc32(a, b, c, d) {
    return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        var t = (a + b) | 0;
        a = b ^ b >>> 9;
        b = c + (c << 3) | 0;
        c = (c << 21 | c >>> 11);
        d = d + 1 | 0;
        t = t + d | 0;
        c = c + t | 0;
        return (t >>> 0) / 4294967296;
    }
}

var individual_seed = 1234
var environment_seed = 2345;
// Pad seed with Phi, Pi and E.
// https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number
// seedable random number generator: https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
var seed = 1010 ^ 0xDEADBEEF;
var rand = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, seed);

function getRandomInt(min, max) {
    return Math.floor(rand() * (max - min + 1)) + min;
}

function getRandomFloat(min, max) {
    return rand() * (max - min) + min;
}

function generateRamdonIndividual() {
    const vertices_num = getRandomInt(3, 10);
    const vertices = [];

    for (let i = 0; i < vertices_num; i++) {
        const x = getRandomFloat(-50, 50, individual_seed);
        const y = getRandomFloat(-50, 50, individual_seed);
        vertices.push({x:x, y:y });
    }

    individual = Bodies.fromVertices(100, -200, vertices, 
                                        {render: { 
                                            fillStyle: '#9F1705', 
                                            strokeStyle: '#000000',
                                            lineWidth: 1 
                                        }});
    individual.restitution = 0.9;
    return individual;
}

var individual1 = generateRamdonIndividual();

function generateRandomRocks(count) {
    const rocks = [];
    const rocks_x_gap = canvas_width/20;
    const rocks_y_gap = canvas_height/20;
    for (let i = 0; i < count; i++) {
        const x = getRandomFloat(rocks_x_gap*i, rocks_x_gap*(i + 1));
        const y = getRandomFloat(100 + rocks_y_gap*i, 100 + rocks_y_gap*(i + 1));
        const radius = getRandomFloat(30, 100);
        const sides = getRandomInt(3, 10);

        const rock = Bodies.polygon(x, y, sides, radius, 
                                    { isStatic: true, 
                                        render: { 
                                            fillStyle: '#F5AF05', 
                                            strokeStyle: '#000000',
                                            lineWidth: 2
                                        }});
        rocks.push(rock);
    }
    return rocks;
}

// 生成40个随机岩石
const mountain = generateRandomRocks(40);
mountain.forEach(function(rock) {
    rock.restitution = 0.9;
});

mountain_com = Composite.create({bodies: mountain});
// add all of the bodies to the world
Composite.add(engine.world, individual1);
Composite.add(engine.world, mountain_com);

// run the renderer
Render.run(render);

// create runner
var runner = Runner.create();

// run the engine
Runner.run(runner, engine);

Events.on(render, 'beforeRender', function() {
    
    if (individual1.position.x > canvas_width/2 && individual1.position.y <= canvas_height/2) {
        Bounds.shift(render.bounds, {x: individual1.position.x - canvas_width/2, y:0});
    }

    if (individual1.position.y > canvas_height/2 && individual1.position.x <= canvas_width/2) {
        Bounds.shift(render.bounds, {x: 0, y:individual1.position.y > canvas_height/2});
    }

    if (individual1.position.x > canvas_width/2 && individual1.position.y > canvas_height/2) {
        Bounds.shift(render.bounds, 
                        {x: individual1.position.x - canvas_width/2, y:individual1.position.y - canvas_height/2});
    }
});


</script>
</body>
</html>
